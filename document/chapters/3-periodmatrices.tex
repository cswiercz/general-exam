%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Computing Period Matrices of Algebraic Curves and the Abel Map}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

In this section we will look at algorithmically computing period
matrices. Each subsection here examines in close detail a major
component of the algorithm and provides a theoretical overview of the
component, an algorithm for computing the component, and an example
presented in {\tt abelfunctions}, a Python software package

%------------------------------------------------------------------------------
\subsection{abelfunctions}
%------------------------------------------------------------------------------

%------------------------------------------------------------------------------
\subsection{Puiseux Series}
%------------------------------------------------------------------------------

%..............................................................................
\subsubsection*{Theory}
%..............................................................................

%..............................................................................
\subsubsection*{Algorithm}
%..............................................................................

\begin{algorithm}[h]
\caption{POLYGON --- Returns the Newton polygon of the polynomial $F =
  F(X,Y)$.}
\label{alg: puiseux-polygon}
\begin{algorithmic}[1]
\Input

$F,X,Y$ --- A polynomial.

$I$ --- If $I=0$, return the Newton polygon. If $I=1$, return only the
segments of the Newton polygon with negative slope. $I=1$ is used to
compute terms beyond the first of the Puiseux series.

\Output A set of lists $(q,m,l,\Phi)$ where
\begin{itemize}
  \item $q,m,l$ defines a line segment $\Delta: qj+mi=l$ in the $(i,j)$
    plane,
  \item $\Phi(Z) = \sum_{(i,j)\in\Delta} a_{ij} Z^{(i-i_0)/q} \in
    \CC[Z]$ where $i_0$ is the smallest value of $i$ such that there is
    a point $(i_0,j)\in\Delta$.
\end{itemize}

\Function{POLYGON}{$F,X,Y,I$}
  \State
\EndFunction
\end{algorithmic}
\end{algorithm}


\begin{algorithm}[h]
\caption{REGULAR --- Given the branching or singular part of a Puiseux
  series, computes the regular part of the series.}
\label{alg: puiseux-regular}
\begin{algorithmic}[1]
\Input

$S$ --- a finite set of pairs $\{(\pi_k,F_k)\}$

$X,Y$ --- the dependent and independent variables, respectively

$H$ --- bound on the number of desired terms of the series

\Output $R$ --- a finite set of pairs $\{(\pi_k,F_k)\}$ containing at
least $H$ terms

\Function{Regular}{$S,X,Y,H$}
  \State $R \leftarrow ()$
  \ForEach{$(\pi,F)$ {\bf in} $S$}
    \While{$\text{len}(\pi) < H$}

      \State $m \leftarrow \text{min} \{ j \; /$
      \Call{COEFFICIENT}{$F,0,j$} $ \; | \; j \neq 0 \}$

      \State $\beta \leftarrow$ \Call{COEFFICIENT}{$F,0,m$} /
      \Call{COEFFICIENT}{$F,1,0$}

      \State $\tau \leftarrow (1,1,m,\beta)$
      \State $\pi \leftarrow \pi \cup \{\tau\}$
      \State $F \leftarrow$ \Call{NEWPOLYNOMIAL}{$F,\tau,m$}
    \EndWhile
    \State $R \leftarrow R \cup \{\pi\}$
  \EndFor
\EndFunction
\end{algorithmic}
\end{algorithm}

%..............................................................................
\subsubsection*{Examples}
%..............................................................................

\begin{lstlisting}
from abelfunctions import *
from sympy.abc import x,y,t

alpha = 0
f = y**8 + x*y**5 + x**4 - x**6
C = RiemannSurface(f,x,y)
p = C.puiseux(alpha, nterms=3, parametric=t)

for pi in p:
    sympy.pprint(pi)
\end{lstlisting}
\begin{pyoutput}
          11    7      
  5    6*t     t     3 
(t , - ----- - -- - t )
         25    5       
           9    5     
   3    2*t    t      
(-t , - ---- - -- + t)
         3     3      
\end{pyoutput}

%------------------------------------------------------------------------------
\subsection{Singularities}
%------------------------------------------------------------------------------

%
\subsubsection*{Theory}
%
%
\subsubsection*{Algorithm}
%
%
\subsubsection*{Examples}
%

%------------------------------------------------------------------------------
\subsection{Holomorphic Differentials}
%------------------------------------------------------------------------------

%
\subsubsection*{Theory}
%



%
\subsubsection*{Algorithm}
%
%
\subsubsection*{Examples}
%

%------------------------------------------------------------------------------
\subsection{Analytic Continuation}
%------------------------------------------------------------------------------

%
\subsubsection*{Theory}
%

A path on a Riemann surface is a continuous map $\gamma : [0,1] \to C
\subset \CC^2$. That is, if $\gamma(t) = (x_\gamma(t), y_\gamma(t))$
then $f(x(t),y(t)) = 0$ for all $t \in [0,1]$.


%
\subsubsection*{Algorithm}
%

Since analytic continuation is repeatedly performed when computing
period matrices it is important to make it performant.

Often, a path in $\CC_x$, $x_\gamma$, will be specified, such as via the
{\sc monodromy() or homology()} functions, and the corresponding
$y$-values lying above need to be determined. A naive approach to doing
so is to use a numerical root finder.

An alternate approach, which is the one used here, is to use Newton's
method --- given $x_\gamma(t_k)$ and some $y_{\gamma,j}(t_k)$ lying
above determine $y_{\gamma,j}(t_{k+1})$ above $x_\gamma(t_{k+1})$.

%
\subsubsection*{Examples}
%

%------------------------------------------------------------------------------
\subsection{Monodromy}
%------------------------------------------------------------------------------

%
\subsubsection*{Theory}
%
%
\subsubsection*{Algorithm}
%
%
\subsubsection*{Examples}
%

%------------------------------------------------------------------------------
\subsection{Homology}
%------------------------------------------------------------------------------

%
\subsubsection*{Theory}
%
%
\subsubsection*{Algorithm}
%
%
\subsubsection*{Examples}
%

%------------------------------------------------------------------------------
\subsection{Period Matrices}
%------------------------------------------------------------------------------

%
\subsubsection*{Theory}
%
%
\subsubsection*{Algorithm}
%
%
\subsubsection*{Examples}
%

%------------------------------------------------------------------------------
\subsection{The Abel Map}
%------------------------------------------------------------------------------

%
\subsubsection*{Theory}
%
%
\subsubsection*{Algorithm}
%
%
\subsubsection*{Examples}
%
